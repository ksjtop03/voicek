▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ MySQL 설치(yum) ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

=======================
   $$ CentOS 기준 $$
=======================

1.mysql 설치
yum install -y mysql-server

2.한글 설정
vi /etc/my.cnf로 가서 아래 # ADD for UTF-8 # 부분 추가
----------------------------------------------------------------------------------
[mysqld]
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
user=mysql
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0


#ADD for UTF-8 #
init_connect = SET collation_connection = utf8_general_ci
init_connect = SET NAMES utf8
character-set-server = utf8
collation-server = utf8_general_ci

[mysqld_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid

#ADD for UTF-8 #
[mysqldump]
default-character-set = utf8

#ADD for UTF-8 #
[mysql]
default-character-set = utf8

#ADD for UTF-8 #
[client]
default-character-set = utf8
----------------------------------------------------------------------------------

3.만약 이미 한글 설정 전에 데이터베이스 작업이 진행되고 있었다면 설정 후 재기동만으로 설정값이 변경되지 않으므로 아래 절차대로 진행한다
 - 데몬 재기동 -> 삭제하려는 DB를 백업해둔다 -> DB삭제(drop) -> DB생성(create) 해야 변경값 적용되어 출력된다


4.root패스워드 지정(*****중요*****)
: mysql을 설치하고나면 초기 root로 접근 시 패스워드가 지정되어 있지 않기때문에 반드시 패스워드를 지정해주어야 한다!!! 

--초기 root 패스워드 설정방법-- mysql_secure_installation이 있는 경로로 가서 실행해준다 (보통 mysql소스파일이 있는 /usr/local/src/mysqlXXX/scripts 경로에 있다 )
mysql_secure_installation 입력(Enter --> Y --> 패스워드 입력 --> 패스워드 재입력 --> 익명의 사용자들을 삭제하는지? --> root원격접속을 허용하지 않는가? --> ....)


5. 패스워드 변경(root로 접속해서 아래와 같이 쿼리를 날린다)
update user set password = password('변경할패스워드') where user = '사용자ID';
-------------------------------------------------------------------------------------------------------------------------------------


#############################################################################################################################################
############################################################### 사용자 추가 및 삭제 ##############################################################
#############################################################################################################################################

----------------사용자 추가----------------
1) root권한으로 mysql접속
mysql -uroot -p

2) mysql DB에 접근
use mysql; 

3) 사용자 및 호스트 확인
select user, host from user;

+--------+-----------+
| user   | host      |
+--------+-----------+
| ksj    | %         |
| kwon   | %         |
| test   | %         |
| root   | 127.0.0.1 |
| ksj    | localhost |
| root   | localhost |
| voicek | localhost |
+--------+-----------+
7 rows in set (0.00 sec)


4) 아래 insert 쿼리로 사용자(패스워드포함) 추가
insert into user(host,user,password) values ('호스트','추가할사용자명',password('패스워드'));
ex) insert into user(host,user,password) values ('%','ksjtop',password('tjrwjs'));		// **외부접근하려면 '%'    (혹시 접근 안될 시 my.cnf에 bind-address 주석처리 되었는지 확인)
																						// **로컬접근하려면 'localhost'


----------------사용자 삭제----------------
drop user '사용자명'@'호스트';

예를 들어, voicek 사용자를 삭제할 경우,

1) 삭제 전 사용자 및 호스트 확인

mysql> select user,host from user;
+--------+-----------+
| user   | host      |
+--------+-----------+
| ksj    | %         |
| kwon   | %         |
| test   | %         |
| root   | 127.0.0.1 |
| ksj    | localhost |
| root   | localhost |
| voicek | localhost |
+--------+-----------+

2) drop으로 삭제
drop user 'voicek'@'localhost';


#############################################################################################################################################
############################################################### 접근권한 설정 ##################################################################
#############################################################################################################################################

1.다른 사용자 생성 및 접근권한 설정
 1-1)root권한으로 mysql에 접근
 : mysql -uroot -p

 1-2)mysql 데이터베이스(use mysql)로 이동 후 아래 select 쿼리로 접근권한 설정상태를 확인
 : select user,host,password from user;

	+------+-----------+-------------------------------------------+
	| user | host      | password                                  |
	+------+-----------+-------------------------------------------+
	| root | localhost | *E2D6EF63C9584765151E5DF73DD6DA16AEB748FC |
	| root | 127.0.0.1 | *E2D6EF63C9584765151E5DF73DD6DA16AEB748FC |
	+------+-----------+-------------------------------------------+
	3 rows in set (0.00 sec)


2.새 사용자 추가 및 접근권한부여
create user '사용자명'@'%' identified by '패스워드';   // ex) create user 'ksj'@'%' identified by 'tjrwjs';
					 				           	   // 여기서 %는 모든(*)와 같은 의미이며, 내부접근허용만을 원할때는 localhost로 변경하면된다.
					       					       // 또는 특정 IP로만 접근하려면 IP를 입력해주면된다


												   
												   
***************************************참고***************************************
--접근권한 부여관련--

1) 특정 사용자에게 특정 DB의 모든 테이블에 select, insert 권한 부여하기
grant select, insert on DB명.* to '사용자명'@'호스트' identified by '비밀번호';

2) 특정 사용자에게 특정 DB의 특정 테이블의 정해준 컬럼에만 update 권한 부여하기
grant update(컬럼1, 컬럼2, 컬럼3,...) on DB명.테이블명 to '사용자명'@'호스트' identified by '비밀번호';

3) 모든 호스트에서 접속가능하고 select 권한만 갖는 사용자 추가하기
grant select on DB명.* to '사용자명'@'%' identified by '비밀번호';

4) IP주소가 192.168.0.으로 시작하는 컴퓨터에서 접속가능한 사용자 추가하기
grant all privileges on *.* to '사용자명'@'192.168.0.%' identified by '비밀번호';


--접근권한 삭제관련--

1) 모든 권한 삭제
revoke all privileges on *.* from '사용자명'@'호스트';		

2) 특정DB 모든 권한 삭제
revoke all privileges on DB명.* from '사용자명'@'호스트';  	

*****만약 특정 계정에 테이블 권한만 주었다가 다시 권한해제를 할 경우*****
-예를 들어, grant all on study.class to 'kwon'@'%' with grant option; 으로 권한을 주었다면
 이를 다시 해제하려면 grant all on 뒤에 동일한 DB명.테이블명을 넣어주어야 한다 
 만약 *.* (모든 DB에 모든 테이블)이런식으로 넣어주면 권한해제가 되지 않는다!!
-----------------------------------------------------------------------------------------------------


--원하는 컬럼에만 권한부여하기
1) select 컬럼 권한부여
grant select(특정컬럼명) on DB명.테이블명 to '사용자명'@'호스트' identified by '패스워드';

ex) grant select(name) on study.class to 'kwon'@'%' identified by 'tjrwjs'; // study DB에 class테이블내에 있는 name컬럼만 select가능하도록 권한부여

select name from class;
+--------------------+
| name               |
+--------------------+
| 게임제작개론           |
| 에자일방법론           |
| 춤                  |
+--------------------+
3 rows in set (0.00 sec)

**여기서 name컬럼 이외에 다른 컬럼은 select할 수 없다(다른 컬럼도 select하고 싶다면 권한부여를 해주어야 한다)


1) update 컬럼 권한부여
grant update(특정컬럼명) on DB명.테이블명 to '사용자명'@'호스트' identified by '패스워드';ㅣ

ex) grant update(cid) on study.class to 'kwon'@'%' identified by 'tjrwjs';  // study DB에 class테이블내에 있는 cid컬럼만 update가능하도록 권한부여

기존 cid값이 3이었는데 아래 쿼리로 cid값을 4로 변경하였음 
update class set cid='4' where name='춤';

mysql> select * from class;
+-----+-----+--------------------+
| cid | pid | name               |
+-----+-----+--------------------+
|   1 |   1 | 게임제작개론           |
|   2 |   2 | 에자일방법론           |
|   4 |   3 | 춤                  |
+-----+-----+--------------------+

**여기서 권한부여된 컬럼(cid)외에 다른 컬럼(pid,name)은 update권한을 부여하지 않았기에 update할 수 없음


******************************************사용자(user)권한 확인*************************************************
1)권한 확인
show grants for 사용자명; (=show grants for '아이디'@'localhost(또는%)';

2)권한 적용
flush privileges

--kwon 계정에 있는 권한 확인--
ex) show grants for kwon;  
+-----------------------------------------------------------------------------------------------------+
| Grants for kwon@%                                                                                   |
+-----------------------------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'kwon'@'%' IDENTIFIED BY PASSWORD '*E2D6EF63C9584765151E5DF73DD6DA16AEB748FC' |
| GRANT SELECT ON `study`.* TO 'kwon'@'%'                                                             |
+-----------------------------------------------------------------------------------------------------+

--접근권한 삭제 후 권한 확인--
ex) show grants for kwon;  // 정상적으로 권한이 삭제 되었음을 확인할 수 있다
+-----------------------------------------------------------------------------------------------------+
| Grants for kwon@%                                                                                   |
+-----------------------------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'kwon'@'%' IDENTIFIED BY PASSWORD '*E2D6EF63C9584765151E5DF73DD6DA16AEB748FC' |
+-----------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

******************************************************************************************************


3.먼저 새 사용자가 접근할 DB 및 테이블을 생성한다(#root권한에서만 생성가능!!)
 3-1)생성 순서
  데이터베이스(DB)생성 -> 테이블(table)생성 -> 테이블 내 컬럼 및 데이터 값 insert

 3-2)DB생성
  create database DB명;

 3-3)table 생성 (#테이블생성 시 반드시 한 개 이상의 컬럼이 있어야만 생성가능)
  create table 테이블명 (컬럼명 타입값, 컬럼명 타입값,...,..);		// ex) create table systeer (no int, name varchar(32));

 **참고**
  만약 database에 접근되지 않은 상태에서 database내에 table을 생성하려면??
  create table DB명.생성할 table명 (컬럼명 타입값, 컬럼명 타입값, .....,....);  // ex) create table cloud.infranics (no int, name varchar(32));


4.접근권한부여
grant all on DB명.* to '사용자명'@'%' with grant option;  // ex) grant all on infanics.* to 'ksj'@'%' with grant option;
													   // DB명.* --> 해당 DB내 모든 테이블 read/write 가능 
						      						   // 만약 ksj사용자에게 특정 테이블만 권한부여하려면 --> DB명.특정테이블명 입력
													   // 특정테이블만 권한부여할 경우, 예를들어 root로 접근 후
						 							   // infranics 데이터베이스 내에 network와 cloud 테이블을 생성하였는데 ksj에게 network에만 
													   // 권한부여해준다면 ksj로 mysql접근 시 cloud 데이터베이스는 확인할 수 없다(read/write 불가)

4-1)권한 적용(*적용을 위해서는 항상 마지막에 flush privileges를 넣어준다)
flush privileges;

#####################################################################################################################################################
################################################################### 데이터베이스(스키마) ################################################################
#####################################################################################################################################################

1.DB생성
create database DB명;



만약 테이블을 삭제하지 않고 스키마를 변경하고 싶다면?(레코드를 삭제하지 않고 스키마변경)
예를들어 uid char(8)을 추가할때
--------------------------------
drop table if exists user;
create table user (
	uid char(8),	// 추가될내용 
	name varchar(32),
	money dec(10,2),
	score int)
	);
--------------------------------

=> ALTER 명령으로 테이블 스키마를 변경할 수 있다

--변경 전--
desc user;
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| name  | varchar(32)   | YES  |     | NULL    |       |
| money | decimal(10,2) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
2 rows in set (0.00 sec)


alter table user add column uid char(12) first;

--변경 후--
desc user;
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| uid   | char(12)      | YES  |     | NULL    |       |
| name  | varchar(32)   | YES  |     | NULL    |       |
| money | decimal(10,2) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
-----------------------------------------------------------------------

select * from user;
+-----+-----------+--------+
| uid | name      | money  |
+-----+-----------+--------+
|     | 홍길동    | 100.00 |
+-----+-----------+--------+
1 row in set (0.00 sec)

update table user set uid=1;

<uid 부분이 추가됨>
select * from user;
+-----+-----------+--------+
| uid | name      | money  |
+-----+-----------+--------+
| 1   | 홍길동    | 100.00 |
+-----+-----------+--------+
1 row in set (0.00 sec)



******************************************************************** 기 타 ********************************************************************
--현재 데이터베이스의 모든 테이블 정보 조회
SELECT ORDINAL_POSITION AS NO, TABLE_NAME, COLUMN_COMMENT,  COLUMN_NAME, COLUMN_TYPE,  IF(IS_NULLABLE = 'YES','','V') AS NOT_NULL
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = SCHEMA()
AND TABLE_NAME IN (
	SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = SCHEMA()
)
ORDER BY TABLE_NAME, ORDINAL_POSITION;
**********************************************************************************************************************************************


#####################################################################################################################################################
################################################################### 테 이 블 #########################################################################
#####################################################################################################################################################

--테이블 생성
create table 테이블명 (타입값);
ex) create table test (id int, name varchar(20));	// int타입의 id컬럼, varchar타입의 name컬럼에 데이터 값을 넣을 수 있도록 test라는 이름의 테이블 생성

--테이블 삭제
drop table 테이블명;
ex) drop table test;	// test테이블 삭제

--테이블명 변경
alter table 테이블명 rename 변경할 테이블명;
ex) alter table test rename master;	 // test테이블의 이름을 master테이블로 변경

--테이블내 데이터값 삭제
delete from 테이블명 where 조건;
ex) delete from stu where id=4;	 // stu테이블안에 있는 컬럼명이 id인 곳에 값이 4인 부분을 삭제한다



create table stu ( id int primary key, name char(8), pid int, constraint stu foreign key (pid) references prof (pid) );


******************************************************************** 기 타 ********************************************************************
--전체 테이블 스키마 정보 조회
SELECT * FROM INFORMATION_SCHEMA.TABLES;

--현재 테이블 스키마 정보 조회
SELECT * FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = SCHEMA();



----------------------------------------------------------------------------------------------------------------
--테스트예제
ex) 테이블 4개 생성

--stu테이블-- 
drop table if exists stu;
create table stu (
	id int(11) primary key default '0',
	name char(8),
	pid int
	);


alter table stu add constraint


--prof테이블--
create table prof (
	pid int primary key,
	name char
	);

--class테이블--
create table class (
	cid int primary key default '0',
	pid int not null,
	name char(20),
	index idx1(pid)
	);


--sugang테이블--
create table sugang (
	cid INT,
	uid INT,
	primary key(cid, uid),
	foreign key(uid) references stu(id),		//수강테이블(sugang)의 uid는 학생테이블(stu)의 id를 참조한다
	foreign key(cid) references class(cid)		//수강테이블(sugang)의 cid는 클래스테이블(class)의 cid를 참조한다
	);
---------------------------------------------------------------------------------------------------------------------------------------

#############################################################################################################################################
################################################################### 컬 럼 ###################################################################
#############################################################################################################################################

--컬럼 추가
alter table [테이블명] add column [컬럼명] [컬럼타입값 no int, name varchar(32), ...];
ex) alter table admin add column name char(32) first;  // admin테이블 내에 name컬럼 추가 **first는 가장 맨 앞에 추가한다는 의미

**컬럼추가 시 위치지정**
alter table [테이블명] add column [추가컬럼명] [컬럼타입값 no int, name varchar(32)...] after [기준컬럼명];
ex) alter table admin add column age int after name;     // 새로 추가될 컬럼명을 기준컬럼명 바로 다음에 넣어준다


--컬럼 삭제
alter table [테이블명] drop column [컬럼명];
ex) alter table admin drop column age;	// admin테이블에 있는 age라는 컬럼을 삭제한다


--컬럼명 변경
alter table [테이블명] change [기존컬럼명] [변경할컬럼명] [컬럼타입값 no int, name varchar 등등의 데이터형 값];
ex) alter table admin change no number int(12);	// admin테이블에 있는 기존 no컬럼명을 number컬럼명으로 변경


--컬럼 타입변경
alter table [테이블명] modify [컬럼명] [변경할 컬럼타입값];
ex) alter table admin modify number name char(8);  // admin테이블에 있는 number컬럼명의 컬럼타입값을 name char(8) 타입으로 변경


**잘 추가 및 변경 되었는지 확인**
desc 테이블명


******************************************************************** 기 타 ********************************************************************
--컬럼 정보 조회
SELECT * FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = SCHEMA() AND TABLE_NAME = '테이블명'
ORDER BY ORDINAL_POSITION;


--컬럼 간단정보 조회
SELECT TABLE_SCHEMA, TABLE_NAME, ORDINAL_POSITION AS NO, COLUMN_NAME, COLUMN_TYPE, COLUMN_DEFAULT AS `DEFAULT`, IS_NULLABLE,  COLUMN_KEY AS `KEY`, COLUMN_COMMENT
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = SCHEMA() 
AND TABLE_NAME = '테이블명'
ORDER BY ORDINAL_POSITION;


--컬럼 권한설정
GRANT SELECT (column_1), INSERT (column_1,column_2) ON DB.* TO '사용자명'@'호스트';


--컬럼권한 확인
SHOW FULL COLUMNS FROM 테이블명;




#####################################################################################################################################################
################################################################### 쿼 리(Select) ####################################################################
#####################################################################################################################################################

1.Select(검색 쿼리)

1-1. 커맨드창에서 select 사용하기
mysql -u "ID" -p "DB명" -e "show databases" --> 패스워드 입력 (ex. mysql -uksj -p infranics -e "show tables")
mysql -u "ID" -p "DB명" -e "show tables" --> 패스워드 입력
mysql -u "ID" -p "DB명" -e "select * from 테이블명" --> 패스워드 입력

1-2.테이블 전체를 보는 쿼리(SQL)
select * from 테이블명;

1-3.select 컬럼1,컬럼2,.... from 테이블명;


1-4.select 조건문(where)
select 컬럼1,컬럼2,... from 테이블명 where 조건;

ex)select id,name,grade from auction_user where grade='D';   // 등급이 D인 사람의 id,name,grade를 출력


1-5.where 뒤에 나오는 조건절
1)부등호 : >, =, <, >=, <> --> '<>'는 아니다를 의미함
ex) select * from auction_user where grade <> 'B';	// 등급이 B가 아닌 사람 출력. 다시말해, B등급이 아닌 나머지 등급의 사람들을 출력

2)논리연산자 : AND, OR

3)문자열 부분검색 : LIKE
select * from auction_user where name like '정%';
select * from auction_user where name like '손%' and money<5000;

*****************참고******************
1) % => 0개 이상의 임의의 글자
2) _ => 1개의 임의의 글자
3) '김%' => 김으로 시작하는 모든 문자열
4) '김_' => 김으로 시작하는 두글자 문자열
5) '_호%' => 두번째 글자가 호인 문자열
***************************************

*****************참고******************
select는 닫힌 연산이다
select의 결과에 또 다시 select를 적용할 수 있다

ex) select a2.id from (select id, name from auser)as a2 where a2.id > 'I';
***************************************

*****************참고******************
#select 결과의 종류#
1)스칼라 : 단 하나의 값이 나온 경우
ex) select name from cloud where name='권석전';
+-----------+
| name      |
+-----------+
| 권석전    |
+-----------+
1 row in set (0.00 sec)


2)튜플 : 하나의 레코드가 결과로 나온 경우
**limit 1은 앞에서 2개의 데이터를 조회하고 싶을 때 사용(앞에서 2개의 데이터를 조회하고 싶을때는 limit 2,.... limit n)

ex) select id,name from auction_user limit 1;
+----+----------+
| id | name     |
+----+----------+
| 1  | 선영▒   |
+----+----------+
1 row in set (0.00 sec)

3)테이블 : 그 외의 경우
ex) select name from auction_user limit 2;
+----------+
| name     |
+----------+
| 선영▒   |
| 이이▒   |
+----------+
2 rows in set (0.00 sec)

4)3번째 이후의 데이터부터 5개의 데이터를 조회함
select no, name from systeer limit 3,5;
+------+--------+
| no   | name   |
+------+--------+
|   28 | 태조   |
|   27 | 정종   |
|   26 | 태종   |
|   25 | 세종   |
|   24 | 문종   |
+------+--------+
5 rows in set (0.00 sec)


---실제 전체 데이터---
+------+-----------+
| no   | name      |
+------+-----------+
|   31 | 권석전    |
|   30 | 홍길동    |
|   29 | 임꺽정    |
|   28 | 태조      |
|   27 | 정종      |
|   26 | 태종      |
|   25 | 세종      |
|   24 | 문종      |
|   23 | 단종      |
|   22 | 세조      |
|   21 | 예종      |
|   20 | 성종      |
+------+-----------+
12 rows in set (0.00 sec)


***************************************

예제1) 소지금액이 1000원 이상 1200원 이하인 사용자의 아이디, 이름, 소지금액을 검색하라.
아래 (1), (2)의 결과는 같지만 (2)번 between구문을 사용하는 것이 좀더 간결하게 사용할 수 있다

(1)select id,name,money 
	from auction_user 
	where money>=1000 and money<=1200;

(2)select id,name,money 
	from auction_user 
		where money between 1000 and 1200;

예제2) 사용자의 등급을 중복제외하고 검색하라
**distinct는 중복되지 않도록 하는 명령어다**

select distinct grade from auction_user;	// grade컬럼의 값들을 중복되지 않게 출력한다

**********주의**********
--DISTINCT, ORDER BY, DESC -- 
: DISTINCT와 ORDER BY는 검색 성능을 느리게 만들 가능성이 높다

예제3) 사용자의 등급을 중복되지 않게 알파벳 내림차순으로 정렬해서 출력하라
select distinct grade from auction_user order by grade desc;
+-------+
| grade |
+-------+
| B     |
| D     |
| G     |
| P     |
| S     |
| U     |
+-------+
6 rows in set (0.00 sec)

**********참고**********

--오름차순정렬--
select distinct grade from auction_user order by grade;  --맨 뒤에 아무것도 안써주면된다
+-------+
| grade |
+-------+
| U     |
| S     |
| P     |
| G     |
| D     |
| B     |
+-------+
6 rows in set (0.01 sec)
--------------------------------------

예제4) 이름이 김씨인 사람을 출력하라
select * from auction_user where name like '김%';


예제5) 김씨이면서 이름이 세 글자인 사람을 출력하라
select * from auction_user where name like '김___';


예제6) B등급 사용자는 몇 명인가요?
select count(*) from auction_user where grade='B';
+----------+
| count(*) |
+----------+
|     1667 |
+----------+
1 row in set (0.00 sec)


**********TIP**********
select count(*) as people_bronze from auction_user where grade='B';	// as "별명" 을 사용하면 아래 출력값과 같이 컬럼명을 보기편하게 출력할 수 있다
+---------------+
| people_bronze |
+---------------+
|          1667 |
+---------------+
1 row in set (0.00 sec)


select grade, count(*) as num_people from auction_user where grade='B';	
+-------+------------+
| grade | num_people |
+-------+------------+
| B     |       1667 |
+-------+------------+
1 row in set (0.00 sec)


예제7) 등급별 사용자 수를 출력하라

--그룹별 유저 수는?--
select grade, count(*) as num_people from auction_user group by grade;	  // 뒤에 group by "컬럼명"을 사용하면 그룹별로 grade(등급) 수를 카운트해준다
+-------+------------+
| grade | num_people |
+-------+------------+
| B     |       1667 |
| D     |       1692 |
| G     |       1630 |
| P     |       1685 |
| S     |       1639 |
| U     |       1686 |
+-------+------------+
6 rows in set (0.00 sec)





#####################################################################################################################################################
################################################################### 쿼 리(Delete) ###################################################################
#####################################################################################################################################################

1.Delete(삭제 쿼리)
delete from 테이블명 where 조건;

*********주의*********
where절이 없으면 전부 다 날라간다

*********TIP*********
delete를 하기 전에 
select * 를 해보고, 삭제할 데이터가 맞으면
select * => delete 로 변경한다.


예제1) 이름이 네글자인 사람을 삭제하라

1)먼저 select로 이름이 네글자인 사람을 검색한다
select * from auction_user where name like '____';

2)확인이 되었으면 아래 delete 쿼리로 삭제한다
delete from auction_user where name like '____';


#####################################################################################################################################################
################################################################### 쿼 리(Update) ###################################################################
#####################################################################################################################################################

1.Update(업데이트 쿼리)
update 테이블명 set 컬럼명 = 값 where 조건;
ex) update sugang set cid=2 where uid=2;	// uid컬럼에 값이 2인 데이터부분에 있는 cid값을 2로 변경

예제1) 이씨들의 등급을 모두 P로 바꾸시오
update auction_user set grade='P' where name like '이%';


예제2) 1,500원 이하인 유저의 돈을 10% 증가시키시오



############################################################################################################################################
############################################################## JOIN(equi-join) ##############################################################
#############################################################################################################################################

*개념 : 두 테이블을 합쳐서 하나로 보여주는 기능(예를들어 FK와 PK가 서로 관계 있는 것끼리 서로 연결해주는 것)
	   JOIN도 닫힌 연산이라 여러 번 조인이 된다
**JOIN = CROSS JOIN

***UNION(유니온)"합집합" : 속성들의 순서와 자료형이 같을 때만 가능(두 테이블의 개수가 같아야 한다)

--stu 테이블
mysql> select * from stu;
+----+-----------+------+
| id | name      | pid  |
+----+-----------+------+
|  1 | 강한용    |    1   |
|  2 | 이뽀삐    |    2   |
|  3 | 박키티    |    1   |
|  4 | 김해피    | NULL   |
+----+-----------+------+
4 rows in set (0.00 sec)

--prof 테이블
mysql> select * from prof;
+-----+-----------+
| pid | name      |
+-----+-----------+
|   1 | 구승모     |
|   2 | 박재성     |
+-----+-----------+
2 rows in set (0.00 sec)


--stu + prof 테이블 join(name값이 join됨)
mysql> select name from stu
    -> union
    -> select name from prof;
+-----------+
| name      |
+-----------+
| 강한용    |
| 이뽀삐    |
| 박키티    |
| 김해피    |
| 구승모    |
| 박재성    |
+-----------+
6 rows in set (0.00 sec)
-------------------------------------------------------


--예제1) 1번 학생이 듣고 있는 수업과 담당 교수 이름을 표시하라
mysql> select s.name, c.name, p.name 
			from stu s    // stu테이블명을 s로 간략히 표시
			join sugang g 	// 
			on s.id = g.uid 
			join class c 
			on g.cid = c.cid 
			join prof p 
			on c.pid = p.pid 
			where s.id = 1;
+-----------+--------------------+-----------+
| name      | name               | name      |
+-----------+--------------------+-----------+
| 강한용     | 게임제작개론          | 구승모      |
| 강한용     | 에자일방법론          | 박재성      |
+-----------+--------------------+-----------+
2 rows in set (0.00 sec)


**좀 더 깔끔하게 출력하려면(컬럼명 구분하려면) as 뒤에 임의컬럼명을 적어준다
mysql> select s.name as 학생명, c.name as 수강명, p.name as 교수명  
			from stu s  
			join sugang g 
			on s.id = g.uid  
			join class c 
			on g.cid = c.cid  
			join prof p 
			on c.pid = p.pid 
			where s.id=1;
+-----------+--------------------+-----------+
| 학생명     | 수강명               | 교수명     |
+-----------+--------------------+-----------+
| 강한용     | 게임제작개론          | 구승모     |
| 강한용     | 에자일방법론          | 박재성     |
+-----------+--------------------+-----------+
2 rows in set (0.00 sec)


--예제2) 지도교수만 출력하라

--우선 학생과 교수의 테이블 전체출력해보자
mysql> select * from stu cross join prof;
+----+-----------+------+-----+-----------+
| id | name      | pid  | pid | name      |
+----+-----------+------+-----+-----------+
|  1 | 강한용     |    1 |   1 | 구승모      |
|  1 | 강한용     |    1 |   2 | 박재성      |
|  2 | 이뽀삐     |    2 |   1 | 구승모      |
|  2 | 이뽀삐     |    2 |   2 | 박재성      |
|  3 | 박키티     |    1 |   1 | 구승모      |
|  3 | 박키티     |    1 |   2 | 박재성      |
|  4 | 김해피     | NULL |   1 | 구승모      |
|  4 | 김해피     | NULL |   2 | 박재성      |
+----+-----------+------+-----+-----------+
8 rows in set (0.00 sec)


--이어 where 조건으로 지도교수만 출력해보면
mysql> select * from stu s
    -> join prof p
    -> where s.pid = p.pid;
+----+-----------+------+-----+-----------+
| id | name      | pid  | pid | name      |
+----+-----------+------+-----+-----------+
|  1 | 강한용     |    1 |   1 | 구승모      |
|  2 | 이뽀삐     |    2 |   2 | 박재성      |
|  3 | 박키티     |    1 |   1 | 구승모      |
+----+-----------+------+-----+-----------+
3 rows in set (0.03 sec)


--예제3) 지도교수 구승모만 출력(#동등조인 = 을 조인 조건에 사용)
mysql> select * from stu s
    -> join prof p
    -> on s.pid = p.pid
    -> where p.name = '구승모';
+----+-----------+------+-----+-----------+
| id | name      | pid  | pid | name      |
+----+-----------+------+-----+-----------+
|  1 | 강한용     |    1 |   1 | 구승모      |
|  3 | 박키티     |    1 |   1 | 구승모      |
+----+-----------+------+-----+-----------+
2 rows in set (0.00 sec)


--예제4) 세타조인, 조인조건이 = 이 아닌 나머지들 출력

**참고 => "<>" : 아닌

mysql> select * from stu s
    -> join prof p
    -> on s.pid <> p.pid 	// 구승모가 교수이고 학생테이블의 pid와 교수테이블의 pid가 다른 학생테이블을 출력하라
    -> where p.name = '구승모';
+----+-----------+------+-----+-----------+
| id | name      | pid  | pid | name      |
+----+-----------+------+-----+-----------+
|  2 | 이뽀삐     |    2 |   1 | 구승모      |
+----+-----------+------+-----+-----------+
1 row in set (0.00 sec)


#############################################################################################################################################
############################################################### 서브쿼리(subquery) ###########################################################
#############################################################################################################################################

--서브쿼리 예제 SQL파일 다운 --> wget https://raw.githubusercontent.com/honux77/introdb/master/subquery/subquery.sql

**개념 : 쿼리 안에 다른 쿼리가 들어가는 형태(=중첩쿼리라고도 부름)
바깥쪽 쿼리 : OUTER QUERY 
안쪽 쿼리 : INNER QUERY, SUB QUERY


--예제1) 맥북을 팔고 있는 유저의 정보를 출력하라.

--쿼리1--
: 먼저 맥북을 팔고 있는 seller를 출력해본다
select seller from trade where item_name = '맥북';

--쿼리2--
: 물음표자리에 쿼리1이 들어가면 된다
select * from user where id = (??) // a2

--서브쿼리--
select * from user where id = (select seller from trade where item_name = '맥북');
+----+-----------+---------------------+-------+------+-----------+
| id | name      | last_visit          | money | choo | trade_num |
+----+-----------+---------------------+-------+------+-----------+
| a2 | 김철수    | 2014-12-22 12:46:53 |   300 | a1   |         0 |
+----+-----------+---------------------+-------+------+-----------+

=========================================================================================
***서브쿼리의 특징***
1)SELECT, INSERT, UPDATE, DELETE 모두에 사용 가능
단, 안쪽 쿼리는 무조건 SELECT 쿼리이다!!!

2)모든 단일 값(스칼라)이 올 수 있는 자리에 사용가능   // 스칼라 --> ex) 1, 50, 'Hello' 등의 하나의 값
3)하나의 레코드가 올 수 있는 자리도 대치 가능   // 여러개의 스칼라가 모여 하나의 레코드
4)테이블(여러 레코드)이 올 수 있는 자리도 대치 가능   //하나 이상의 레코드


--예제2) GTA5를 팔고 있는 유저 1명의 정보를 출력하라.
select * from user u 
where u.id 
in ( select seller from trade t where item_name = 'GTA5') limit 1;
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
+----+-----------+---------------------+--------+------+-----------+


*******************참고********************
where 다음에 이퀄 '='은 하나의 값만 올 수 있지만
  in은 중복(2개이상 복수의 값) 스칼라가 올 수 있다.
select * from user u 
where u.id 
in ( select seller from trade t where item_name = 'GTA5');
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
| a2 | 김철수    | 2014-12-22 12:46:53 |    300 | a1   |         0 |
+----+-----------+---------------------+--------+------+-----------+


***스칼라값 대체 쿼리***
참고)스칼라 값 대체할 때 주의사항 
: 서브쿼리의 결과값으로 두 개의 값이 오면 에러 발생


in, not in은 스칼라 집합에 대해 사용가능

--예제3) 아이폰을 팔고 있는 유저의 정보를 모두 출력하라.(결과값이 하나가 아니라 둘 이상이기 때문에 where id 다음에 이퀄 '='이 아닌 in을 사용한다)
select * from user 
where id 
in (select seller from trade where item_name like '아이폰%');
+----+-----------+---------------------+-------+------+-----------+
| id | name      | last_visit          | money | choo | trade_num |
+----+-----------+---------------------+-------+------+-----------+
| a3 | 김영희    | 2014-12-22 12:46:53 | 10000 | a2   |         0 |
| a4 | 이영수    | 2014-12-22 12:46:53 |  2000 | a3   |         0 |
+----+-----------+---------------------+-------+------+-----------+


--예제4) 아이폰을 팔고있지 않은 유저의 정보를 모두 출력하라(not in 사용)

select * from user 
where id 
not in (select seller from trade where item_name like '아이폰%');
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
| a2 | 김철수    | 2014-12-22 12:46:53 |    300 | a1   |         0 |
| a5 | 최순희    | 2014-12-22 12:46:53 |   7777 | NULL |         0 |
+----+-----------+---------------------+--------+------+-----------+


--예제5) 2번 마켓에서 가장 많은 상품을 팔고 있는 사람의 정보를 출력하라.

--먼저 가장 많이 판매하고 있는 seller를 출력해본다

1)select seller from trade;	//a2 seller가 총 3개로 가장 많다
+--------+
| seller |
+--------+
| a1     |
| a2     |
| a2     |
| a3     |
| a4     |
| a3     |
| a4     |
| a2     |
+--------+

2)select seller, count(*) as num_item from trade group by seller;	// seller를 group으로 묶어서 출력
+--------+----------+
| seller | num_item |
+--------+----------+
| a1     |        1 |
| a2     |        3 |
| a3     |        2 |
| a4     |        2 |
+--------+----------+


3)최종 서브쿼리결과
select * from user 
where id = ( select seller from trade group by seller order by count(*) desc limit 1);
+----+-----------+---------------------+-------+------+-----------+
| id | name      | last_visit          | money | choo | trade_num |
+----+-----------+---------------------+-------+------+-----------+
| a2 | 김철수    | 2014-12-22 12:46:53 |   300 | a1   |         0 |
+----+-----------+---------------------+-------+------+-----------+







************************************************************************************
**************************ANY, ALL을 사용하는 서브쿼리************************************
************************************************************************************
1) ANY
컬럼 이름 비교연산자 ANY (쿼리)
: 결과값에 하나라도 만족하면 TRUE

--예제1) 적어도 하나의 상품을 구매가능한 유저의 정보를 출력하라. 


--user테이블 전체 출력 	// 이중에서 김철수의 money는 300이라서(돈이 부족하여) 물건을 구입할 수 없다
select * from user;
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
| a2 | 김철수    | 2014-12-22 12:46:53 |    300 | a1   |         0 |
| a3 | 김영희    | 2014-12-22 12:46:53 |  10000 | a2   |         0 |
| a4 | 이영수    | 2014-12-22 12:46:53 |   2000 | a3   |         0 |
| a5 | 최순희    | 2014-12-22 12:46:53 |   7777 | NULL |         0 |
+----+-----------+---------------------+--------+------+-----------+


--결과출력
select * from user
where money > any (select price from trade);
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
| a3 | 김영희    | 2014-12-22 12:46:53 |  10000 | a2   |         0 |
| a4 | 이영수    | 2014-12-22 12:46:53 |   2000 | a3   |         0 |
| a5 | 최순희    | 2014-12-22 12:46:53 |   7777 | NULL |         0 |
+----+-----------+---------------------+--------+------+-----------+


2) ALL
컬럼이름 비교연산자 ALL (쿼리)
: 서브 쿼리의 모든 결과를 만족시키는 경우만 TRUE

--예제2) 마켓의 어떤 물건이라도 구매 가능한 유저의 정보를 출력하라.
select * from user 
where money > all (select price from trade);
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
+----+-----------+---------------------+--------+------+-----------+

//아래 ALL 쿼리 대신에 max함수를 사용하여 결과값을 출력할 수도 있다
select * from user where money > (select max(price) from trade);
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
+----+-----------+---------------------+--------+------+-----------+

--> 정호영이라는 사람만이 마켓의 모든 물건을 살 수 있다.




************************************************************************************
*************************************상관쿼리****************************************
************************************************************************************

1)상관쿼리 (성능이 좋지 않다)
: 바깥 쿼리 테이블의 속성이 안쪽 쿼리에 나오는 경우

select * from 테이블명1
where 컬럼명1 = ( select 컬럼명3 from 테이블명2 
		where 테이블명1.컬럼명2 = 테이블명2.컬럼명4);


**비상관 쿼리의 동작 방식
안쪽쿼리 실행 --> 스칼라 값 추출 --> 바깥쿼리 실행 --> 최종결과

**상관쿼리의 동작 방식
바깥쪽쿼리 실행 --> 레코드 하나의 각각의 값이 안쪽 쿼리를 만족


--예제1) 유저 자신의 판매 물품 가격의 총합이 그 유저의 재산보다 많은 유저의 정보를 출력하라
select * from user u
    -> where money > (select sum(price) as sum_price from trade t where seller = id);
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
+----+-----------+---------------------+--------+------+-----------+


2)EXISTS와 NOT EXISTS
--EXISTS(서브쿼리) : 쿼리가 하나 이상 나오면 참

--money가 1이상인 유저가 존재하는지 확인--
: 존재하기 때문에 결과값이 1이 나온다 (참: 1, 거짓 : 0)
select exists (select * from user where money > 1);
+---------------------------------------------+
| exists (select * from user where money > 1) |
+---------------------------------------------+
|                                           1 |
+---------------------------------------------+



--NOT EXISTS(서브쿼리) : 결과가 하나라도 있으면 거짓

주로 상관쿼리에 사용되며, 앞에 컬럼 이름이 나오지 않음


--예제2) 2번 마켓에 판매 물품이 없는 유저를 검색하라
select * from user 
where not exists (select * from trade where seller = id and marketid=2);
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
| a4 | 이영수    | 2014-12-22 12:46:53 |   2000 | a3   |         0 |
| a5 | 최순희    | 2014-12-22 12:46:53 |   7777 | NULL |         0 |
+----+-----------+---------------------+--------+------+-----------+
	

3)FROM절의 서브쿼리
FROM절에도 쿼리가 올 수 있다
반드시 테이블에 별명을 붙여줘야 한다

--------------------------------------------------
select m.name, m.item_name
	FROM
	(SELECT *
	FROM user u LEFT JOIN
	TRADE t ON u.id = t.seller) AS m;
--------------------------------------------------

--예제-- 
select m.name, m.item_name 
from (select * from user u left join  trade t on u.id = t.seller)
as m;   // 여기서 m은 테이블의 별명이다
+-----------+--------------------+
| name      | item_name          |
+-----------+--------------------+
| 정호영    | GTA5               |
| 김철수    | GTA5               |
| 김철수    | 맥북               |
| 김철수    | 체리키보드         |
| 김영희    | 아이폰4            |
| 김영희    | 갤럭시             |
| 이영수    | 페라리마우스       |
| 이영수    | 아이폰5            |
| 최순희    | NULL               |
+-----------+--------------------+



4)VIEW
**개념 : SELECT 쿼리를 이용해서 만든 가상 테이블 / 용량을 차지 않음


-생성 : create view 명령 사용
create view 뷰이름 as (SELECT...);

-사용 : 일반적인 테이블과 동일
SELECT * FROM 뷰이름...;

-삭제 : DROP VIEW 명령 사용
DROP VIEW 뷰이름;


--가상테이블 생성--
create view testview 
	as(select * from user where not exists 
		(select * from trade where seller = id and marketid=2));

--가상테이블 사용--
select * from testview;
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
| a4 | 이영수    | 2014-12-22 12:46:53 |   2000 | a3   |         0 |
| a5 | 최순희    | 2014-12-22 12:46:53 |   7777 | NULL |         0 |
+----+-----------+---------------------+--------+------+-----------+

--가상테이블 삭제--
drop view testview;
=========================================================================================


***셀프조인***
테이블이 자기 자신과 조인하는 것을 말함

ex) 사용자와 추천인의 이름을 보여줘라

--------------------------- 전  체 ---------------------------------------
select * from user;
+----+-----------+---------------------+--------+------+-----------+
| id | name      | last_visit          | money  | choo | trade_num |
+----+-----------+---------------------+--------+------+-----------+
| a1 | 정호영    | 2014-12-22 12:46:53 | 500000 | a1   |         0 |
| a2 | 김철수    | 2014-12-22 12:46:53 |    300 | a1   |         0 |
| a3 | 김영희    | 2014-12-22 12:46:53 |  10000 | a2   |         0 |
| a4 | 이영수    | 2014-12-22 12:46:53 |   2000 | a3   |         0 |
| a5 | 최순희    | 2014-12-22 12:46:53 |   7777 | a4   |         0 |
+----+-----------+---------------------+--------+------+-----------+
--------------------------------------------------------------------------

select u1.name as user, u2.name choo
    -> from user u1
    -> left join user u2
    -> on u1.choo = u2.id;
+-----------+-----------+
| user      | choo      |
+-----------+-----------+
| 정호영    | 정호영    |
| 김철수    | 정호영    |
| 김영희    | 김철수    |
| 이영수    | 김영희    |
| 최순희    | 이영수    |
+-----------+-----------+

#############################################################################################################################################
################################################################### LEFT JOIN ###############################################################
#############################################################################################################################################

**개념 : 왼쪽 테이블의 안맞는 부분도 출력해준다

mysql> select * from stu 
left join prof 
on stu.pid = prof.pid;
+----+-----------+------+------+-----------+
| id | name      | pid  | pid  | name      |
+----+-----------+------+------+-----------+
|  1 | 강한용   	 |    1 |    1 | 구승모     |
|  2 | 이뽀삐   	 |    2 |    2 | 박재성     |
|  3 | 박키티   	 |    1 |    1 | 구승모     |
|  4 | 김해피   	 | NULL | NULL | NULL      |
+----+-----------+------+------+-----------+
4 rows in set (0.01 sec)


#############################################################################################################################################
################################################################### RIGHT JOIN ##############################################################
#############################################################################################################################################

*개념 : 오른쪽 테이블의 안맞는 부분도 출력해준다

mysql> select * from stu 
right join prof 
on stu.pid = prof.pid;
+------+-----------+------+-----+-----------+
| id   | name      | pid  | pid | name      |
+------+-----------+------+-----+-----------+
|    1 | 강한용     |    1 |   1 | 구승모      |
|    3 | 박키티     |    1 |   1 | 구승모      |
|    2 | 이뽀삐     |    2 |   2 | 박재성      |
| NULL | NULL      | NULL |   3 | 정호영     |
+------+-----------+------+-----+-----------+
4 rows in set (0.00 sec)


#############################################################################################################################################
################################################################ FULL OUTER JOIN ############################################################
#############################################################################################################################################

**개념 : 양쪽 테이블 다 출력해준다(단, MySQL에는 full outer join이 없기 때문에 union을 사용해야한다)

select * from stu 
left join prof 
on stu.pid = prof.pid
union
select * from stu 
right join prof 
on stu.pid = prof.pid;

+------+-----------+------+------+-----------+
| id   | name      | pid  | pid  | name      |
+------+-----------+------+------+-----------+
|    1 | 강한용    |    1 |    1 | 구승모      |
|    2 | 이뽀삐    |    2 |    2 | 박재성      |
|    3 | 박키티    |    1 |    1 | 구승모      |
|    4 | 김해피    | NULL | NULL | NULL      |
| NULL | NULL     | NULL |    3 | 정호영     |
+------+-----------+------+------+-----------+
5 rows in set (0.00 sec)


#############################################################################################################################################
################################################################## Group By #################################################################
#############################################################################################################################################

***Group By 컬럼 Having 조건명령어***

: Group By에 명시된 컬럼을 기준으로 같은 값끼리 그룹을 형성하고 해당 그룹에 대해 그룹함수를 적용해서 결과를 보여준다.
 Having 명령어로 그룹에 조건을 줄 수도 있다
: Group By의 조건은 having으로 기술하는게 정석
**집합함수는 having으로만 가능

======================================================================================================================
1) Group By "컬럼명" 으로 그룹을 만든다
2) Group함수를 이용해서 결과생성
3) Where절이 아닌!! Having을 이용해서 Group By에 조건을 줄수있고 조건절에 Group 함수를 쓰고 싶다면 반드시 Having을 써야한다
======================================================================================================================


--예제1) 등급별 인원수를 구하시오.
select grade, count(*) from auction_user group by grade;
+-------+----------+
| grade | count(*) |
+-------+----------+
| B     |     1667 |
| D     |     1692 |
| G     |     1630 |
| P     |     1685 |
| S     |     1639 |
| U     |     1686 |
+-------+----------+
6 rows in set (0.00 sec)

--G그룹에 인원수 출력
select grade, count(*) from auction_user where grade='G';
+-------+----------+
| grade | count(*) |
+-------+----------+
| G     |     1630 |
+-------+----------+
1 row in set (0.00 sec)


--1650명 이상의 등급별 출력(**집합함수는 having으로만 가능)
select grade, count(*) as num_user 
from auction_user 
group by grade 
having num_user > 1650;
+-------+----------+
| grade | num_user |
+-------+----------+
| B     |     1667 |
| D     |     1692 |
| P     |     1685 |
| U     |     1686 |
+-------+----------+
4 rows in set (0.01 sec)




*** 다양한 그룹함수 ***
:자주쓰는 그룹함수 COUNT, MAX, MIN, SUM, AVG 등등

--예제2) 등급별 인원수, 평균보유금액, 최대보유금액을 구하시오

select grade, count(*), 
max(money) as max_money, 
avg(money) as avg_money 
from auction_user 
group by grade;
+-------+----------+-----------+-----------+
| grade | count(*) | max_money | avg_money |
+-------+----------+-----------+-----------+
| B     |     1667 |      9900 | 4871.9856 |
| D     |     1692 |      9900 | 4881.1466 |
| G     |     1630 |      9900 | 5009.2638 |
| P     |     1685 |      9900 | 5012.2849 |
| S     |     1639 |      9900 | 5060.4027 |
| U     |     1686 |      9900 | 4879.3594 |
+-------+----------+-----------+-----------+
6 rows in set (0.01 sec)


--예제3) 다이아와 브론즈 등급의 재산 총합을 각각 구하시오(*참고로 group by는 문장에 맨 마지막에 사용)

select grade, sum(money) 
from auction_user 
where grade = 'B' or grade = 'D' group by grade;
+-------+------------+
| grade | sum(money) |
+-------+------------+
| B     |    8121600 |
| D     |    8258900 |
+-------+------------+
2 rows in set (0.00 sec)


select grade, sum(money) 
from auction_user 
group by grade
having grade = 'B' or grade = 'D';




#############################################################################################################################################
################################################################## CASE WHEN #################################################################
#############################################################################################################################################

1) 일반 프로그래밍 언어의 switch ~ case와 유사
2) CASE ~ WHEN ... 자체가 하나의 값처럼 동작

==================================================================================
---쿼리문---
SELECT 컬럼명,
CASE 컬럼명 
	WHEN '컬럼명내 값1' THEN 변경할 값1
	WHEN '컬럼명내 값2' THEN 변경할 값2
	             .
	             .
	             .
	             .
	WHEN '컬럼명내 값X' THEN 변경할 값X
ELSE '나머지 값'
END 가독성을 위한 컬럼명
FROM 테이블명;


--CASE문 예제--
SELECT grade,
CASE grade
	WHEN 'D' THEN 1
	WHEN 'P' THEN 2
	WHEN 'G' THEN 3
	ELSE 4
END ngrade
FROM auction_user;
==================================================================================


--예제1) 등급을 숫자로 바꾸고 숫자의 오름차순으로 정렬해서 표시하라.
select grade, 
case grade 
	when 'D' then 1 
	when 'P' then 2 
	when 'G' then 3 
	else 4 
end as ngrade 
from auction_user 
group by grade 
order by ngrade;
+-------+--------+
| grade | ngrade |
+-------+--------+
| D     |      1 |
| P     |      2 |
| G     |      3 |
| U     |      4 |
| S     |      4 |
| B     |      4 |
+-------+--------+




#############################################################################################################################################
############################################################### 백 업 / 복 원 ################################################################
#############################################################################################################################################

1. 백업

1) Database 전체백업
mysqldump -uroot -p -A > test.txt

2) 특정 Database 백업
mysqldump -uksj -p cloud systeer > 1121.sql 	// mysqldump -u 사용자명 -p DB명 > 저장될파일명.sql

3) 특정 테이블 백업
mysqldump -uksj -p cloud systeer > 1121.sql 	// mysqldump -u 사용자명 -p DB명 테이블명 > 저장될파일명.sql




2. 복원(2가지 방법)

1) 커맨드창에서 전체 DB 복원(**단, 복원할 데이터베이스명이 존재하지 않으면 생성한 후 복원해야한다)
mysql -u "ID" -p "패스워드" < "복원할파일명"
ex) mysql -uroot -ptjrwjs infranics < test.sql

2) mysql로 접근 후 아래 쿼리 입력
source "복원하려는 백업파일명.sql"



#############################################################################################################################################
################################################################### JDBC ####################################################################
#############################################################################################################################################


--DB 연동테스트 쿼리--
--------------------------------------------------------------------------
import java.sql.*;

class jdbc {
        public static void main(String argv[]) {
        try {
        Class.forName("org.gjt.mm.mysql.Driver");
        System.out.println("jdbc 드라이버 로딩 성공");
        } catch(ClassNotFoundException e){
        System.out.println(e.getMessage());
        }

        try{
         String url="jdbc:mysql://localhost/mysql";
         Connection con = DriverManager.getConnection(url,"root","tjrwjs");
         System.out.println("mysql접속성공");
         Statement stmt = con.createStatement();
         ResultSet rs = stmt.executeQuery("select user from user where user = 'root'");
         System.out.println("Got result");

        while(rs.next()){
         String no= rs.getString(1);
         String tblname= rs.getString(1);
         System.out.println("no=" + no);
         System.out.println("tblname=" + tblname);
        }

        stmt.close();
        con.close();
        } catch(java.lang.Exception ex){
         ex.printStackTrace();
        }
    }
}
------------------------------------------------------------------------------------------------


**Prepare Statement**
 
Insert를 할 때마다 쿼리 스트링값을 바꾸면?

귀찮다.
속도도 느리다
사실 쿼리는 바뀌지 않고 값만 바뀌는 일이 많다
그래서 Prepare Statement를 사용

------------------------------------------------------------------------------------------------
**JSP(JAVA Server Page) : 웹페이지 안에 JAVA코드가 들어가는 것(#html안에 java코드 삽입) 참고로 반대방식으로 작동하는 서블릿도 있다
요즘은 spring 등의 프레임워크를 더 많이 사용

JSP의 주요 이슈는 한글처리(get, post 방식)
데이터베이스 한글처리, 보안 등이 있다


-----------------------------------------------------------
--JSP 실습환경구축

yum install -y java-1.7.0-openjdk-devel.x86_64
javac -version
yum install -y net-tools unzip wget
wget http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.56/bin/apache-tomcat-7.0.56.tar.gz

tar.gz파일 압축해제
mv apache-tomcat-7.0.56 tomcat7
cd tomcat/bin
chmod +x startup.sh
chmod +x shutdown.sh
chmod +x catalina.sh

./startup.sh

--mysql 연동
wget http://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.0.8.tar.gz
tar.gz 압축해제
톰캣경로/lib/ --> tar.gz로 압축해제한 jar파일을 이 경로에다가 넣어준다
./shutdown.sh
./startup.sh


#############################################################################################################################################
################################################################### 기 타 ####################################################################
#############################################################################################################################################

1. mysql 정보보기(버전 및 characterset, SSL, current user, current database 등등) 
status 


2. DB 내에 테이블 생성 시 최소 한 개이상의 컬럼을 만들어야지 테이블이 생성된다.
create table cloud.systeer (no int, name varchar(32));

3. 테이블 내에 컬럼 확인
desc 테이블명;

ex) **출력물**
mysql> desc auction_user;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id    | char(4) | NO   | PRI | NULL    |       |
| name  | char(8) | YES  |     | NULL    |       |
| grade | char(1) | YES  |     | NULL    |       |
| money | int(11) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
4 rows in set (0.00 sec)


4. 현재시간 확인쿼리
select now();


unsigned : unsigned 형식
default '0' : 디폴트 값 0 으로 설정
not null : null 이 될수 없음
auto_increment : 자동증가
primary key : 기본키 설정

5. myqsl clear방법
Ctrl + L을 누르면 command창에 clear와 동일한 기능


6.쿼리 플랜 보기
explain select 문장 \G

ex) explain select * from auction_user\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: auction_user
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9999
        Extra:
1 row in set (0.01 sec)
**************************************************************


ex) explain select * from user where not exists (select * from trade where seller = id and marketid=2);
+----+--------------------+-------+------+---------------+----------+---------+-------+------+-------------+
| id | select_type        | table | type | possible_keys | key      | key_len | ref   | rows | Extra       |
+----+--------------------+-------+------+---------------+----------+---------+-------+------+-------------+
|  1 | PRIMARY            | user  | ALL  | NULL          | NULL     | NULL    | NULL  |    5 | Using where |
|  2 | DEPENDENT SUBQUERY | trade | ref  | marketid      | marketid | 5       | const |    4 | Using where |
+----+--------------------+-------+------+---------------+----------+---------+-------+------+-------------+

--컬럼 설명--
1)select_type
SIMPLE, PRIMARY : 가장 바깥 쿼리
SUBQUERY : 일반 서브쿼리
DERIVED : FROM절의 서브쿼리 (* 가능하면 없애자)
DEPENDENT SUBQUERY : 바깥테이블과 연관된 서브쿼리 (* 가능하면 없애자)

2)table
테이블 이름 또는 종류

3)type
실제 데이터 읽는 방법
SYSTEM, CONST, REF, RANGE, INDEX, ALL 등이 있음(**여기서 SYSTEM이 가장 빠르고 ALL이 가장 느림 / INDEX는 INDEX FULL SCAN, 빠르지 않음)

4)key
쓸모없는 컬럼이므로 무시
실제 데이터를 읽기 위해 사용되는 인덱스의 이름
필요에 의해 생성한 인덱스가 잘 사용되는지 확인

5)key_len
인덱스 중 사용할 수 있는 크기를 나타낸다
복합 인덱스에서 매우 중요

6)rows
예상 레코드 개수, 이를 위해 통계정보를 저장

7)Extra
이름과는 달리 매우 중요한 정보들이 저장되지만 패스


------------------------------------요약------------------------------------------
1. 쿼리가 원하는 성능이 안나올 경우 튜닝 실시
2. explain 명령으로 원인 분석
3. DEPENDENT SUBQUERY, DERIVED와 같은 타입이 나오지 않게!!
4. 되도록 all이 나오지 않게!!!
----------------------------------------------------------------------------------

====================================================================================================================

7.mysql 테이블 engine type 확인쿼리
: mysql접속 후, 해당 데이터베이스로 이동하여 아래 쿼리를 입력하면 Engine필드에서 각 테이블의 Engine타입을 확인할 수 있다

1) table status 에서 확인 
QUERY : show table status;	//특정 데이터베이스로 가서 확인
+--------------+--------+---------+------------+------+----------------+-------------+-------------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+
| Name         | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length   | Index_length | Data_free | Auto_increment | Create_time         | Update_time         | Check_time | Collation       | Checksum | Create_options | Comment |
+--------------+--------+---------+------------+------+----------------+-------------+-------------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+
| auction_user | MyISAM |      10 | Fixed      | 9999 |             44 |      439956 | 12384898975268863 |       175104 |         0 |           NULL | 2016-12-04 15:07:06 | 2016-12-04 15:07:06 | NULL       | utf8_general_ci |     NULL |                |         |
| class        | InnoDB |      10 | Compact    |    2 |           8192 |       16384 |                 0 |        16384 | 485490688 |           NULL | 2016-11-23 18:10:13 | NULL                | NULL       | utf8_general_ci |     NULL |                |         |
| dept         | MyISAM |      10 | Fixed      |    4 |             41 |         164 | 11540474045136895 |         3072 |         0 |           NULL | 2016-11-23 17:11:38 | 2016-11-23 17:13:28 | NULL       | utf8_general_ci |     NULL |                |         |
| line_memo    | MyISAM |      10 | Dynamic    |   12 |             30 |         368 |   281474976710655 |         2048 |         0 |             13 | 2016-11-27 01:30:45 | 2016-11-27 01:48:51 | NULL       | utf8_general_ci |     NULL |                |         |
| market       | InnoDB |      10 | Compact    |    3 |           5461 |       16384 |                 0 |            0 | 485490688 |           NULL | 2016-12-04 18:18:18 | NULL                | NULL       | utf8_general_ci |     NULL |                |         |
| prof         | InnoDB |      10 | Compact    |    3 |           5461 |       16384 |                 0 |            0 | 485490688 |           NULL | 2016-11-23 18:10:13 | NULL                | NULL       | utf8_general_ci |     NULL |                |         |
| stu          | InnoDB |      10 | Compact    |    6 |           2730 |       16384 |                 0 |        16384 | 485490688 |           NULL | 2016-11-23 18:10:13 | NULL                | NULL       | utf8_general_ci |     NULL |                |         |
| sugang       | InnoDB |      10 | Compact    |    5 |           3276 |       16384 |                 0 |        16384 | 485490688 |           NULL | 2016-11-23 18:10:13 | NULL                | NULL       | utf8_general_ci |     NULL |                |         |
| test         | MyISAM |      10 | Fixed      |    5 |              7 |          35 |  1970324836974591 |         1024 |         0 |           NULL | 2016-12-05 10:11:03 | 2016-12-05 10:24:31 | NULL       | utf8_general_ci |     NULL |                |         |
| trade        | InnoDB |      10 | Compact    |    8 |           2048 |       16384 |                 0 |        16384 | 485490688 |              9 | 2016-12-04 18:18:18 | NULL                | NULL       | utf8_general_ci |     NULL |                |         |
| user         | InnoDB |      10 | Compact    |    5 |           3276 |       16384 |                 0 |        16384 | 485490688 |           NULL | 2016-12-04 18:18:18 | NULL                | NULL       | utf8_general_ci |     NULL |                |         |
+--------------+--------+---------+------------+------+----------------+-------------+-------------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+


2) information_schema 데이터베이스에서 확인 
QUERY : select table_schema,table_name,engine from information_schema.tables where table_schema='DB명';

ex) select table_schema,table_name,engine from information_schema.tables where table_schema='popidb';
+--------------+--------------+--------+
| table_schema | table_name   | engine |
+--------------+--------------+--------+
| popidb       | auction_user | MyISAM |
| popidb       | class        | InnoDB |
| popidb       | dept         | MyISAM |
| popidb       | line_memo    | MyISAM |
| popidb       | market       | InnoDB |
| popidb       | prof         | InnoDB |
| popidb       | stu          | InnoDB |
| popidb       | sugang       | InnoDB |
| popidb       | test         | MyISAM |
| popidb       | trade        | InnoDB |
| popidb       | user         | InnoDB |
+--------------+--------------+--------+


3) 테이블 Engine Type 변경
 3-1) 변경할 테이블에 데이터베이스에 먼저 접근 후

 3-2) 아래 쿼리실행
	ALTER TABLE 테이블명 TPYE = 변경할 TYPE명;
	ex) alter table auction_user type = InnoDB;

 3-3) 변경 후 확인(맨 아래줄 ENGINE 부분 확인)
	SHOW CREATE TABLE auction_user;
+--------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table        | Create Table                                                                                                                                                                                                    |
+--------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| auction_user | CREATE TABLE `auction_user` (
  `id` char(4) NOT NULL,
  `name` char(8) DEFAULT NULL,
  `grade` char(1) DEFAULT NULL,
  `money` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+--------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

******* 주의사항 *******
실 데이터를 가지고 있는 테이블에서는 데이터의 손실이 있을 수도 있으므로 사용에 주의할 것!!



************************데이터베이스 Engine(=스토리지 엔진)타입*********************************
MySQL에는 그 특성에 따라 여러 종류의 데이터베이스 엔진(스토리지 엔진 이라고도 함)이 존재. 가장 많이 알려져 있고 또 가장 많이 사용하고 있는 엔진은 MyISAM과 InnoDB이다.
이전 까지는 MyISAM이 MySQL의 기본 엔진이었다면 MySQL 5.5부터는 InnoDB가 기본 엔진으로 변경.

여러면에서는 InnoDB가 좋지만 성능면에서는 MyISAM가 좋다.
MySQL이 프리웨어 데이터베이스로 많이 활용되면서 웹 게시판과 같은 단일 트랜젝서 환경 또는 대규모 동시 처리에 대한 요구가 없는 환경에서 사용되다 보니 기본 엔진이 MyISAM에 적합했었다. 
그러다가 Oracle에 인수 된 이후 엔터프라이즈용으로도 많이 사용되면서 InnoDB가 더 각광을 받게 됐을지도 모른다.

MyISAM은 트랜젝션 지원이 안되기 때문에 여러 SQL문을 실행한 후 commit또는 rollback하는 기능이 없고, 테이블 단위로 락이 걸려 있기 떄문에
테이블에 두 가지 이상의 데이터를 동시에 insert/update 할 수 없다

+ 트랜젝션이란? 
 정확성을 보장하기 위해 완전히 종료해야하는 데이터베이스 처리의 논리적 단위를 표현하는 개념.
대부분의 DBMS에서는 데이터의 일관성 및 동시성을 보장하기 위해 트랜잭션을 제공.


1) MyISAM
-상대적으로 높은 성능
-읽기 위주의 요청에 유리
-테이블 단위 락킹 

-장점 : 항상 테이블 명세에 row count를 가지고 있기 때문에 select count(*) from TABLE 이런식의 명령을 사용할 때 엄청 빠르다.
-단점 : 많은 단점이 있지만 제일 큰 단점은 row level locking이 아닌 table level locking을 지원하기 때문에 한 테이블에 많은 접근이 이루어질수록 속도가 느려짐.

또한 트렌젝션을 지원하지 못하기 때문에 delete update를 잘못 사용 할 경우 백업 안하였을 경우에 큰 아픔이 따름.


2) InnoDB 특징
-트랜젝션 지원(rollback, commit 기능제공)
-빈번한 쓰기, 수정, 삭제시 처리 능력
-디스크, 전원 등의 장애 발생시 복구 성능
-동시처리가 많은 환경에 적합
-Row 단위 락킹 

-장점 : 트랜젝션 지원, row level Locking 지원(ms-sql도 row level locking을 지원하지만 한 테이블에 locking이 많아질 경우 lock escalation(테이블 전체에 락이 걸리는 경우)가 있는데 mysql의 InnoDB에는 없음)
-단점 : 풀 텍스트 인덱스를 지원 못함, 속도가 약간 느림, 테이블의 row 수의 정보를 가지고 있지 않기 때문에 select count(*) from TABLE 같은 식의 명령을 내릴때 innodb_buffer_pool에 해당 테이블의 인덱스 정보가 모두 들어가 있지 않다면 다시 스토리지 엔진이 하나하나 수를 계산하여 결과를 보여주기 때문에 매우 느림( 단 인덱스 컬럼으로 where 조건을 주어 count 하면 MyISAM과 동일한 속도를 보임)


3) Memory




==================================================================================================================================================================
====================================================================RollBack 및 Commit 기능 사용법====================================================================
==================================================================================================================================================================



********************************************************************** Rollback / Commit 수행 전 확인사항!! ***********************************************************************
--Commit auto기능 설정상태 확인--
show variables like 'autocommit';

--Commit auto기능 설정하기--
set autocommit=0; // '자동 commit기능 OFF상태'로 쿼리 수행 시 마다 commit 명령어를 수행해야지 변경된 값 적용됨!! (**쿼리 수행 시 마다 commit 명령어를 입력하지 않으면 변경된 값이 적용되지 않음)
set autocommit=1; // '자동 commit기능 ON상태'로 쿼리 수행 시 자동으로 commit 되어 테이블에 쓰여지게 된다 (**만약 이전 단계로 원복하고 싶다면 쿼리수행 전에 start transaction; 혹은 begin; 명령어로 트랜젝션을 시작해준다음 
	                   					    	               						     쿼리를 수행하고 rollback; 명령어로 원복을 하면된다)
*******************************************************************************************************************************************************************************

1) RollBack 테스트해보기
> start transaction; (= begin;)	//쿼리 수행 전 먼저 트랜젝션 시작!

> insert into 테이블명 values ('컬럼 데이터값');	//테스트할 테이블 생성 및 데이터 값 insert
  ex) insert into test values (1);	

> update 테이블명 set 변경할 데이터값의 컬럼명 = '변경할 값' where 컬럼 = 데이터값;	 //데이터 값 update
  ex) update test set int = 2 where int = 1;  // 1을 2로 변경

> rollback; //rollback을 수행하면 2로 update된 값이 이전 1로 원복된다


2) Commit 기능 

--먼저 autocommit 상태 확인 (만약 Rollback 기능을 사용하려면 )
show variables like 'autocommit';	// 만약 Value값이 On('1')으로 되어 있으면 Off로 변경해준다 (이 옵션은 변경된 데이터의 내용을 테이블에 바로 쓰지 않기 위함이다)
+---------------+-------+			// set autocommit을 OFF('0')로 설정하면 commit명령어를 내리기 전까지는 테이블에 적용하지 않는다
| Variable_name | Value |			// rollback 명령어를 내리면 이전 값으로 되돌려 놓는다
+---------------+-------+ 			// Myisam 타입은 이 autocommit의 값이 OFF('0')라도 변경된 값이 바로 테이블에 쓰여지게 된다
| autocommit    | ON    |
+---------------+-------+

**autocommit Value값이 ON('1')일 때 : 쿼리수행 시 변경된 값이 바로 테이블에 쓰여지게 된다 (**따로 commit 명령어를 입력하지 않아도 바로 쓰여짐)
  => rollback 기능을 사용하고 싶다면 쿼리수행 전마다 [start transaction;] 혹은 [begin;] 명령어를 입력 후 쿼리를 수행해야 한다  --> 쿼리수행 이후에 바로 전단계로 원복하고 싶다면 [rollback;] 명령어를 수행한다

**autocommit Value값이 OFF('0')일 때 : 쿼리수행 시 변경된 값을 적용하려면 쿼리수행 시 마다 반드시 commit 명령어를 입력해야 한다
  => 쿼리수행 시 마다 commit 명령어를 수행하지 않으면 변경된 값이 적용되지 않으므로 주의!!!






-------------------------------------------------------------------------------------------------------------------------
    ############################################### 참고 ###########################################################

create table auction_user(						// auction_user테이블을 생성하겠다
	id char(16),								// char데이터형의 id컬럼 생성
	name varchar(32) not null,					// not null(값이 없는 것)은 null을 설정하지 못한다는 것. 공백없이 값을 넣으라는 말
	birth date,									// date타입의 birth컬럼
	last datetime,			
	money dec(8,2) not null default 1000,		// 값을 입력하지 않으면 default 값 1000을 준다는 말
	primary key(id),							// 
	unique(name)
	);

**참고로 primary key 나 unique key는 null값이 올 수 없고 반드시 not null이 와야된다
-------------------------------------------------------------------------------------------------------------------------


5. Script파일 실행
ex. mysql에 접근해서 아래 쿼리 실행
source C:\test.SQL   // source "스크립트 경로"



◈ 테이블 컬럼 타입
 
# 날짜 및 시간 관련 컬럼 타입 

 - DATE 
   날짜를 표현하는 유형 [YYYY-MM-DD], 1000-01-01 ∼ 9999-12-31까지 나타낼 수 있다
 - DATETIME 
   날짜와 시간을 표현하는 유형 [YYYY-MM-DD HH:MM:SS],  1000-01-01 00:00:00 ∼ 9999-12-31 23:59:59 
 - TIMESTAMP 
   자동변경 컬럼 타입(4 Byte ),  1970-01-01 00:00:00부터 2037년 까지 표현 
 - TIME 
   시간을 표현하는 유형 [HH:MM:SS],   839:59:59 ∼ 833:59:59 까지 표현
 - YEAR 
   년도를 표현하는 유형[기본적으로 4자리로 사용],  1901년 ∼ 2155년 

# 문자 컬럼 타입

 - CHAR(M) 
   고정길이 문자열 컬럼,   M의 범위는 0 에서 255까지.
 - VARCHAR(M) 
   가변길이 문자열 컬럼,   M의 범위는 0 에서 255까지.
 - TINYBLOB 또는 TINYTEXT 
   최대길이 255개의 문자를 저장 
 - BLOB 또는 TEXT 
   최대 길이가 63535인 문자를 저장 
 - MEDIUMBLOB 또는 MEDIUMTEXT 
   최대 길이가 16777215인 문자를 저장 
 - LONGBLOB 또는 LONGTEXT 
   최대 길이가 4294967295(4G)인 문자를 저장 

 * 참고 

  - BLOB(Binary Large Object의 약자
  - BLOB타입은 대소문자를 구분하고 TEXT타입은 대소문자를 구분하지 않는점이 틀림
  - MySQL 3.23.2이번 버전에서는 BLOB와 TEXT컬럼에는 인덱스를 만들수 없다
  - BLOB와 TEXT컬럼의 저장시에 문자열 됫부분의 공백이 제거되지 않는다.
  - BLOB와 TEXT컬럼은 DEFAULT를 지정할 수 없다.


# 숫자 컬럼 타입
 
 - TINYINT 
    -128부터 127 까지의 정수형 타입,   부호가 없는 정수 0∼255까지 지원
 - SMALLINT 
    -32768부터 32767 까지의 정수형 타입,  부호가 없는 정수 0∼65535까지 지원
 - MEDIUMINT 
    -8388608부터 8388607 까지의 정수형 타입,   부호가 없는 정수 0∼16777215까지 지원
 - INT 또는 INTEGER 
   -2147483648부터 2147483647까지의 정수형 타입,  부호 없는 정수 0∼4294967295까지 지원
 - BIGINT 
   -9223372036854775808 부터 9223372036854775807 까지의 정수형 타입
   부호 없는 정수 0∼18446744073709551615까지 지원
 - FLOAT(M,D)
   단정도 부동 소수점 실수,   -3.402823466E+38 ∼ -1.175494351E-38 
   그리고 1.175494351E-38 ~ 3.402823466E+38까지  M은 숫자 전체의 길이, D는 소수점 자리수를 의미
 - DOUBLE(M,D)
   2 배 정밀도를 가진 부동 소수점 실수,   -1.79769313486231517E+308 ∼ 2.22507385850720E+308 


◈ 제약조건

# AUTO_INCREMENT(Oracle : Sequence)

-- 생성예제
mysql>CREATE TABLE sal(
           sal_id INT NOT NULL AUTO_INCREMENT, 
           name VARCHAR(30) NOT NULL);

 - AUTO_INCREMENT로 지정된 컬럼 타입은 숫자형이어야 한다 .
 - AUTO_INCREMENT는 하나의 테이블에 하나의 컬럼만 지정할 수 있음
 - AUTO_INCREMENT로 지정된 컬럼은 반드시 키 또는 인덱스로 정의되어야 한다. 


# NOT NULL : NULL값을 허락하지 않음
# PRIMARY KEY : 중복된 데이터를 허락하지 않음, NOT NULL 조건도 추가
# UNIQUE : 중복된 데이터를 허락하지 않음, NULL값을 허락한다.
# DEFAULT value : 디폴트 값을 지정함    


-- 예제..
mysql>CREATE TABLE emp2(
            id INT(3) NOT NULL, 
            name VARCHAR(30) NOT NULL
            sal INT(5) DEFAULT 0,
            loc VARCHAR(50),
            PRIMARY KEY(id, name));


--기본키 삭제--
ALTER TABLE 테이블명 DROP PRIMARY KEY


--테이블 쿼리 자세히 보기
show create table 테이블명\G



=============================================
ERD를 그릴 때
--> 관계 모델

참조 무결성 제약조건?
: NULL, 또는 부모테이블에서 가지고 있는 값만 가져야 한다
emp(id, ..., deptno) // 4? (X) // 부모테이블에서 1,2,3번 부서뿐이 없기때문에 4번 부서는 올 수 없다
              ^
              |
      +-------+
      |
 dept(dno, ...) // 1, 2, 3 "부모테이블"

 ex) 
------------------------------------------------------------
  trade 테이블
-----------------------------------------------------------
 tid (int)	item (varchar 32)	price (dec 10,2)	seller_id (char 8)
                                                               ^// seller_id값은 반드시 user테이블의 uid값을 가지던지 혹은 NULL값을 가져야한다
                                                               |__________   			// 여기서 NULL 값은 판매자가 아직 없다는 의미로 쓰임
                                                               			  |
-----------------------------------------------------------				  |	
  user 테이블															      |
-----------------------------------------------------------				  |
uid (char 8)	name(varchar 32)	money (int)		score (int)			  |
   |																	  |
   |______________________________________________________________________|

--**외래키 제약조건 추가**
ex) alter table trade
      add foreign key (seller_id) references user(uid);  // alter table 테이블명 add foreign key (컬럼명) references 부모테이블명(primary key 컬럼);




--외래키 제약조건을 삭제하려면?
우선 show create table 테이블명\G 쿼리로 constraint 값을 확인한다(만약 constraint값이 dept_ibfk_1이라면 이 부분을 삭제해준다)
alter table trade drop foreign key trade_ibfk_1;



===========================================================================
select * from 테이블명 별칭 
	join 테이블명 별칭
	where 별칭.pid = 별칭.pid;

ex) select * from stu s
		join prof p
		where s.pid = p.pid;

===========================================================================


******************************HideiSQL사용법******************************
DB서버에 mysql설치 후 클라이언트에서 hideisql을 사용해서 DB에접속하여 세션을 맺으면 
처음에는 information_schema 데이터베이스만 보여질 것이다.

이는 DB서버에서 root로 접속 후 해당 데이터베이스에 권한부여를 부여해야 권한부여된 데이터베이스를 
확인 할 수 있다
************************************************************************


****************다중 테이블스페이스 사용하기***********************
InnoDB 테이블과 인덱스 파일을 각자의 파일에 저장할 숙다 있다. 이러한 특성을 다중테이블스페이스라고 하는데, 그 이유는 실제로 각각의 테이블의 자신만의 테이블스페이스를 가지고 있기 때문이다

다중 테이블스페이스를 사용하는 것은 특정 테이블을 물리적으로 구분된 여러 개의 디스크에 분산하기를 원하거나 또는 남아 있는 InnoDB테이블에 대한 인터럽트 없이 하나의 테이블 백업을 리스토어 하고자 하는 사용자에게 편리하다

**아래의 라인을 my.cnf의 [mysqld] 섹션에 추가하면 다중 테이블스페이스를 활성화 시킬 수가 있다.
[mysqld]
innodb_file_per_table 




----------------------------------------

*******주의************
2019-06-20 하기 bin log format 파라미터 값을 on 시켜야할 경우, 반드시 mixed 로 지정해야
다른 파라미터 isolation~~~?  과 충돌나지 않는다!!!

# binary logging format - mixed recommended
# binlog_format=mixed



